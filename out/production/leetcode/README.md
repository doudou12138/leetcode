# leetcode
一个专门用来刷leetcode的仓库
以前的leetcode记录已丢失o(╥﹏╥)o
<h1>目录</h1>

35:<a href="#35"> 搜索插入位置 </a> e  
42:<a href="#42"> 取水</a> h  
55:<a href="#55"> 跳跃游戏 </a> m  
54:<a href="#54"> 螺旋矩阵 </a> m  
59:<a href="#59"> 螺旋矩阵2 </a> m  
62:<a href="#62"> 不同路径 </a> m  
69:<a href="#69"> x的平方根 </a> e  
209:<a href="#209"> 长度最小的子数组 </a>m  


<h2 id="35">35:搜多插入位置</h2>
难度:简单
<h3>要求:</h3>
时间复杂度logn
<h3>思路:</h3>
那就不能顺序查找,二分查找即可.理清二分查找在落入最后两项的情景下的情景即可

二分查找的注意点:
- 当中间有值与之相等时,会搜到,直接返回
- 当中间无值与之相等时,最后会落入仅a,b两项的局面
  - 若a,b均非首尾值,则目标值在其之间
  - 若a是首值,则目标值可能等于小于a
  - 若b是尾部值,则目标值可能大于等于b
  - 本来原队列就只有两个数


<h2 id="42"> 42: 取水 </h2>
难度:困难



<h2 id="54"> 54: 螺旋矩阵 </h2>

难度:中等  
思路:  
从外到内剥开矩阵,每一次剥记录left,top,right,bottom.然后依次取出上右下左的元素  
注意点:  
当right=left时,就不取出right的元素  
当bottom=top时,就不取出bottom的元素



<h2 id="55">55: 跳跃游戏 </h2>

难度:中等  
思路:  
逆向思维.不断记录能跳到终点的最小下标位置
只要中间不会中断,可以到0即可.
~~~
public boolean canJump(int[] nums) {
        //最小下标位置初始化为len-1,即最后一位
        int canIdx=nums.length-1;
        
        for (int idx = nums.length-2; idx >=0 ; --idx) {
            //如果当前位置能到达,最小下标位置;则最小下标位置更新
            if(idx+nums[idx]>= canIdx){
                canIdx=idx;
            }
            //如果当前位置不能到达则继续向左边遍历即可
        }
        return canIdx==0;
}
~~~




<h2 id="59"> 59: 螺旋矩阵 2 </h2>

难度:中等  
思路:  
54题按层模拟的思想依然可行



<h2 id="62"> 62: 不同路径 </h2>

难度:中等
<h3>思路:</h3>
- f(m,n)=f(m-1,n)+f(m,n-1)  
这里使用递归,是会出现重复的计算的.所以要使用"备忘录"将一些已经计算过的进行存储
- 上面方法的变式.逆向思维
- 需要向右m-1步,向下n-1步.共m+n-2步,就是在这m+n-2步中确定向下的n-1步即可(排列组合)
注意要先除小的数



<h2 id="69">69:x的平方根</h2>
难度:简单
<h3>要求:</h3>
x范围是0~2^31-1
<h3>思路:</h3>
本题ac不难.主要是如何ac得更优雅
- 从0开始遍历.i*i=x时返回i,i\*i>x时返回i-1  
**当x=2^31-1时,最后i\*i绝对会溢出**考虑用除法
- 当x/i=i时返回i,x/i<i时返回i-1;规避了乘积溢出的情况.但要注意别让除数为0
- 别信楼上,为啥遍历,不如用**2分查找**
- 牛顿迭代法(结合数学)


<h2 id="209">209: 长度最小的子数组 </h2>
难度:中等
<h3>要求:</h3>
时间复杂度n.
<h3>思路:</h3>
滑动窗口.右边向前不断扩大sum,一旦sum到了target,左边向前缩小sum,产生一次len,与上一次len比较.  
注意点:   
与上一次len比较,不能直接返回min(len,right-left+1).因为len初始值为0,导致min会一直为0.